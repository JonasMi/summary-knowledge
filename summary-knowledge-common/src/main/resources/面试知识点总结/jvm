内存划分

1.方法区
存放被虚拟机加载的类信息，常量，静态变量，

2.java堆
存放对象实例，数组。

3.java线程栈
和程序计数器相同，线程私有，它的生命周期与线程相同。每个方法被创建的时候都会创建一个栈帧：用于
存储局部变量表，操作栈，动态链接，方法出口等信息。


4.程序计数器
当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取
下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成
每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响。线程私有

5.本地方法栈

6.直接内存

常量池:-XX:PermSize=10M -XX:MaxPermSize=10M
堆大小设置:-Xms、-Xmx
-XX:-HeapDumpOnOutOfMemoryError 当首次遭遇OOM时导出此时堆中相关信息 
-XX:HeapDumpPath=./java_pid<pid>.hprof 指定导出堆信息时的路径或文件名 
-XX:-PrintGC 每次GC时打印相关信息 
-XX:-PrintGC Details 每次GC时打印详细信息 
-XX:PrintHeapAtGC:打印GC前后的详细堆栈信息 
-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析。 
-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行 调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。 
-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。 对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活 时间，增加在年轻代即被回收的概论。 
-XX:MaxPermSize=16m:设置持久代大小为16m。 
-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 
-XXarallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。 
-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 
-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。 
-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。 
-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩 





